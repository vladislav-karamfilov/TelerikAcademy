<#+
/// <summary>
/// Generates a file block per entity thas needs to be rendered definition.
/// </summary>
/// <param name="@class">The class object.</param>
private void GeneratePerEntityFileBlock(Telerik.OpenAccess.CodeGeneration.CodeElement element, Telerik.OpenAccess.CodeGeneration.CodeNamespace @namespace, string defaultExtension)
{
	this.templateContext.StartNewFileBlock(Path.ChangeExtension(element.Name, defaultExtension), @namespace.Name); 
	//foreach (string @using in this.utilities.GetRequiredUsings(element as Telerik.OpenAccess.CodeGeneration.CodeInterface))
	//{
	//	if(!string.IsNullOrEmpty(@using))
	//	{
	//	}

	string entityNamespace = string.Empty;
	entityNamespace = !string.IsNullOrEmpty(@namespace.Name) ? @namespace.Name : this.GetEntityNamespace(element as Telerik.OpenAccess.CodeGeneration.CodeInterface);
	if(this.generateMultipleFiles)
	{
		this.GenerateUsings(element as Telerik.OpenAccess.CodeGeneration.CodeInterface);	
	}
		if (!String.IsNullOrEmpty(entityNamespace)) 
		{#>

namespace <#=entityNamespace #>	
{
<#+  	}
	if (element is Telerik.OpenAccess.CodeGeneration.CodeClass)
	{
		this.GenerateClass(((Telerik.OpenAccess.CodeGeneration.CodeClass)element));
	}
	else if(element is Telerik.OpenAccess.CodeGeneration.CodeInterface)
	{
		this.GenerateInterface(((Telerik.OpenAccess.CodeGeneration.CodeInterface)element));
	}

	if (!string.IsNullOrEmpty(entityNamespace)) 
	{#>
}
<#+	}
	this.templateContext.EndBlock();
}

/// <summary>
/// Generates a file's header.
/// </summary>
private void GenerateFileBlockHeader()
{
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
<#+
}

///<summary>
/// Internal counter of the number of namespaces that have been opened
///</summary>
private static int openNamespaceCounter = 0;


/// <summary>
/// Generates a namespace statement
/// </summary>
private void OpenNamespace(string ns)
{
	OpenNamespace(ns, false);
}

///<summary>
/// Generates a namespace statement, and optionally resets
/// the count of open namespaces.
///</summary>
///<Remarks>
/// If resetCount is true, the counter that tracks the number of
/// open namespaces will be reset. Only set this parameter to 
/// true when opening the first namespace in a .tt file.
///</Remarks>
private void OpenNamespace(string ns, bool resetCount)
{
	if (string.IsNullOrEmpty(ns))
	{
		throw new ArgumentNullException("ns");
	}
	
	if (resetCount)
	{
		openNamespaceCounter = 0;
	}
	
	openNamespaceCounter++;

	// Write the namespace declaration to the output stream	
	this.GenerationEnvironment.AppendLine("namespace " + ns);
	this.GenerationEnvironment.AppendLine("{");
}

/// <summary>
/// Closes a namespace
/// </summary>
/// <remarks>
/// This method checks that there is a namespace that needs to be closed, and throws an exception
/// if there isn't.
/// </remarks>
private void CloseNamespace()
{
	// Check that there are still namespaces that need to be closed.
	if (openNamespaceCounter < 1)
	{
		// Replace any text that has been generated with a warning message,
		// then throw an exception.
		this.GenerationEnvironment = new System.Text.StringBuilder();
		this.GenerationEnvironment.AppendLine("Generation error - see output window for details.");
		throw new InvalidOperationException("There are no open namespaces that need to be closed");
	}
	openNamespaceCounter--;
#>
}
<#+
}

#>
<#+

/// <summary>
/// Generates a class definition.
/// </summary>
/// <param name="@class">The class object.</param>
private void GenerateClass(Telerik.OpenAccess.CodeGeneration.CodeClass codeClass)
{
	this.PushIndent("\t");
	this.GenerateSummary(codeClass.Summary);
	this.GenerateComments(codeClass.Comments);	
	
	string classSignature = GetClassSignature(codeClass);
	
	this.GenerateCustomAttributes(codeClass.Attributes);
	this.WriteLine(classSignature);
	this.WriteLine(classOpenToken);
	if (!codeClass.DoubleDerived)
	{
		this.GenerateProperties(codeClass.Properties);
		//GenerateAssociations(@class);
		//GenerateOperations(codeClass.BaseClass.Functions);		 
		//if(codeClass.NestedClasses.Count > 0)
		//{
		//	this.GenerateNestedOIDClasses(codeClass);
		//}
	}
	this.WriteLine(classCloseToken);

	// Doing the double derivation
	if (codeClass.DoubleDerived)
	{
		string baseClassSignature = GetBaseDerivationClassSignature(codeClass);
	
		this.GenerateSummary(codeClass.BaseClass.Summary);
		this.GenerateComments(codeClass.BaseClass.Comments);
		this.WriteLine(baseClassSignature);
		this.WriteLine(classOpenToken);
		this.GenerateProperties(codeClass.DoubleDerivationBaseClass.Properties);
		//GenerateAssociations(@class);
		//GenerateOperations(codeClass.BaseClass.Functions);
		this.WriteLine(classCloseToken);
	}
	this.PopIndent();
}

/// <summary>
/// Generates the attributes definition.
/// </summary>
/// <param name="properties">The list of properties.</param>
private void GenerateProperties(System.Collections.Generic.IEnumerable<Telerik.OpenAccess.CodeGeneration.CodeProperty> properties)
{
	PushIndent("\t");
	//ProcessPropertiesIfAutoImplementedSettingIsOn(properties);
	properties.ForEach(
		property => 
		{
			GenerateProperty(property);
		});

	PopIndent();
}

/// <summary>
/// Generates a property definition.
/// </summary>
/// <param name="property">CodeProperty instance to generate.</param>
private void GenerateProperty(Telerik.OpenAccess.CodeGeneration.CodeProperty property)
{
	bool isPropertyVirtual = (property.PropertyInheritanceModifier == Telerik.OpenAccess.CodeGeneration.MemberInheritanceModifier.None);
	bool isPropertyAbstract = (property.PropertyInheritanceModifier == Telerik.OpenAccess.CodeGeneration.MemberInheritanceModifier.Abstract);
	bool isPropertyPrivate = (property.PropertyAccessModifier == Telerik.OpenAccess.CodeGeneration.MemberAccessModifier.Private);
	bool areModifiersCompatible = !(isPropertyAbstract && isPropertyPrivate);
	string accessModifier = this.utilities.Context.GetMemberAccessModifier(property.PropertyAccessModifier);
	string inheritanceModifier =  this.utilities.GetMemberInheritanceModifier(property.PropertyInheritanceModifier);
	
	// private access modifier is not compatible with virtual inheritance modifier
	// by default the inheritance modifier is None which is handled as virtual
	if (isPropertyPrivate && isPropertyVirtual)
	{
		 inheritanceModifier = string.Empty;
	}
	string modifiers = string.Format("{0}{1}",accessModifier, inheritanceModifier).TrimEnd();
	
	if(property.Name.Contains(".")) //Handles explicit interface member implementation e.g. ICustomer.Company
	{
		modifiers = string.Empty;
	}
	string propertyType = this.GetTypeStringPresentation(property);
	string errorMessage =  string.Empty;
	string propertyErrorMessage = string.Empty;
	if(!areModifiersCompatible) 
	{
		errorMessage =  this.utilities.Context.GetIncompatibleModifiersErrorMessage(property, this.modelSettings, this.defaultExtension, this.Host.TemplateFile);
		propertyErrorMessage = this.utilities.Context.GetPropertyErrorMessageForIncompatibleModifiers(property.Name, "private", "abstract");		
	}
	
	if(!string.IsNullOrEmpty(property.FieldName))
	{
		string initialValue = string.Empty;
		if(!string.IsNullOrEmpty(property.DefaultValue))
		{
			initialValue = string.Concat(" = ", property.DefaultValue);
		}
		string fieldModifier = "private";
		if(property.UserData.Contains("isFieldProtected") && (bool)property.UserData["isFieldProtected"])
		{
		fieldModifier = "protected";
		}
		
	 	if (!isPropertyAbstract)
		{ 
#>
<#= fieldModifier #> <#= propertyType #> <#= property.FieldName #><#= initialValue #>;
<#+ 	} 
		if (!areModifiersCompatible)
		{
			this.WriteLine("//TODO: Please, resolve the following error: {0}", propertyErrorMessage);
			this.Error(errorMessage);
		}		

this.GenerateSummary(property.Summary);	
this.GenerateCustomAttributes(property.Attributes); #>
<#= modifiers #> <#= propertyType #> <#= property.Name #> 
{ 
<#+
if(property.HasGetter)
{
	if (isPropertyAbstract)
	{
#>
    get;
<#+			 
	}
	else
	{
#>
    get
    {
        return this.<#= property.FieldName #>;
    }
<#+	
	}
}
if(property.HasSetter)
{
	if (isPropertyAbstract)
	{
#>
    set;
<#+			 
	}
	else
	{
#>
    set
    {
		if( this.<#= property.FieldName #> == value)
		{
			return;
		}
        this.<#= property.FieldName #> = value;
		this.RaisePropertyChanged("<#= property.FieldName #>");
    }
<#+		         
	}
}
#>
}

<#+
	}
	else
	{
		if (!areModifiersCompatible)
		{
			this.WriteLine("//{0}", errorMessage);
			this.Error(errorMessage);
		}
GenerateCustomAttributes(property.Attributes); 	
#>
<#= modifiers #> <#= propertyType #> <#= property.Name #>
{
<#+
		if(property.HasGetter)
		{
#>
    get;
<#+			 
		}
		if(property.HasSetter)
		{
#>
    set;
<#+			 
		}
#>
}

<#+
	}
}

/// <summary>
/// Generates the operations signatures and bodies.
/// </summary>
/// <param name="functions">The list of functions.</param>
private void GenerateOperations(IEnumerable<Telerik.OpenAccess.CodeGeneration.CodeFunction> functions)
{
	functions.ForEach(
		function =>
		{
			PushIndent("\t");
			GenerateSummary(function.Summary);
			if(function.FunctionInheritanceModifier == Telerik.OpenAccess.CodeGeneration.MemberInheritanceModifier.Abstract || function.Partial)
			{
#>

<#= utilities.GetPartialOperationSignature(function)#>;

<#+
			}
			else
			{
#>

<#= utilities.GetOperationSignature(function)#>

<#+
			//GenerateOperation(function);
			}
#>

<#+
			PopIndent();
		});
}

private string GetContextName()
{
	return (new string[] { this.modelSettings.ModelContextName, this.generatedContext.Name, "MyContext" }).FirstOrDefault(s => !String.IsNullOrEmpty(s));
}

private string GetEntityNamespace(Telerik.OpenAccess.CodeGeneration.CodeInterface element)
{
	return (new string[] {element != null ? element.Namespace : string.Empty, this.defaultNamespace }).FirstOrDefault(s => !String.IsNullOrEmpty(s));
}


#>